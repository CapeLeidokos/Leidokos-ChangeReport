#!/usr/bin/python
  
# -*- coding: utf-8 -*-

# -*- mode: python -*-
#
# Leidokos-ChangeReport
#
# Copyright (C) 2019  Noseglasses (shinynoseglasses@gmail.com)
#
# This program is free software: you can redistribute it and/or modify it under it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with along with
# this program. If not, see <http://www.gnu.org/licenses/>.
#         

import subprocess
import argparse
import sys
import os
import re
import inspect
import datetime

program_name = "Leidokos-ChangeReport"

def which(program):
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None
       
def findSketches(repo_dir):
      
   sketches = []
   
   print "Finding sketches in %s" % (repo_dir)
   
   for root, dirs, files in os.walk(repo_dir):
      for file in files:
         if file.endswith(".ino"):
            my_relpath_root = os.path.relpath(root, repo_dir)
            sketches.append(os.path.join(my_relpath_root, file))
            
   return sketches

def listIntersection(l1, l2):
   return sorted(list(set(l1) & set(l2)))

class Sketch(object):
   pass

class DriverFile(object):
   
   def __init__(self, filename):
      
      self.filename = filename 
      
      self.file = open(filename, "w")
      
      self.writeFileHeader()
      
   def writeFileHeader(self):
      
      self.file.write("# This is an auto generated elf_diff driver file\n")
      self.file.write("# Generated by {program_name} {date}\n".format( \
         program_name = program_name, \
         date = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
      self.file.write("\n")
      
   def writeParameter(self, name, value):
      
      if "\n" in value:
         self.file.write("{name}: >\n".format(name = name))
         lines = value.split("\n")
         for line in lines:
            self.file.write("  {line}\n".format(line = line))
      else:
         self.file.write("{name}: \"{value}\"\n".format(name = name, value = value))
      
   def writeRaw(self, strg):
      self.file.write(strg)

class LCR(object):
   
   def __init__(self):
      
      self.parseCommandLineArgs()
      self.collectBuildInfo()
      self.generateBundleSubmoduleInfoFiles()
      
      if self.old_repo_path:
         if not self.new_repo_path:
            print "Please define either two or no Kaleidoscope repo paths"
            exit(1)
            
         # Generate mass report
            
         self.collectExamplePairs()
         self.buildSketches()
         self.generateMassReportDriverFile()
         self.generateMultiReport()
         
      else:
         
         # Generate pair report
         
         self.buildFirmwares()
         self.generatePairReportDriverFile()
         self.generatePairReport()
         
      self.cleanup()
      
   def generateOutputFilename(self, extension):
      return self.report_target_dir + "/" + self.report_file_basename + "." + extension

   def collectExamplePairs(self):
      
      self.old_sketches = set(findSketches(self.old_repo_path))
      self.new_sketches = set(findSketches(self.new_repo_path))
      
      self.common_sketches = set(listIntersection(self.old_sketches, self.new_sketches))
      
      self.sketches_only_old = sorted(self.old_sketches - self.common_sketches)
      self.sketches_only_new = sorted(self.new_sketches - self.common_sketches)
      
      #for sketch in self.common_sketches:
      #   print "Sketch %s" % (sketch)
      
   def buildSketches(self):
      
      self.sketches = []
      
      for sketch_file in self.common_sketches:
         
         sketch = Sketch()
         
         sketch.relpath = os.path.relpath(sketch_file, "examples")
         sketch.dir_relpath = os.path.dirname(sketch.relpath)
         sketch.basename = os.path.basename(os.path.splitext(sketch_file)[0])
         
         extra_env = {
             "LIBRARY" : sketch.dir_relpath
            ,"SKETCH" : sketch.basename
         }
      
         old_hardware_path = self.old_repo_path + "/../../../.."
         new_hardware_path = self.new_repo_path + "/../../../.."
         
         print "*** Building %s" % (sketch_file)
               
         sketch.old_firmware_binary \
            = self.buildFirmware(old_hardware_path, self.old_repo_path, \
                                 sketch_file = self.old_repo_path + "/" + \
                                    sketch_file, \
                                 extra_env = extra_env, \
                                 make_command = "compile" )
         
         sketch.new_firmware_binary \
            = self.buildFirmware(new_hardware_path, self.new_repo_path, \
                                 sketch_file = self.new_repo_path + "/" + \
                                    sketch_file, \
                                 extra_env = extra_env, \
                                 make_command = "compile")

         self.sketches.append(sketch)
         
   def generateMassReportDriverFile(self):
      
      self.driver_file = self.generateOutputFilename("driver.yaml")
            
      if self.change_title:
         project_title = "Kaleidoscope: " + self.change_title
      else:
         project_title = "Kaleidoscope: <Unknown Change>"
         
      html_file = self.generateOutputFilename("html")
      pdf_file = self.generateOutputFilename("pdf")
      
      f = DriverFile(self.driver_file)
         
      f.writeParameter("project_title", project_title)
      f.writeParameter("bin_dir", self.arduino_path + "/hardware/tools/avr/bin")
      f.writeParameter("bin_prefix", "avr-")
      f.writeParameter("pdf_file", pdf_file)
      f.writeParameter("html_file", html_file)
      f.writeParameter("old_info_file", self.old_bundle_submodule_info_file)
      f.writeParameter("new_info_file", self.new_bundle_submodule_info_file)
      f.writeParameter("build_info", self.build_info)
      f.writeParameter("mass_report", "True")
      
      f.writeRaw("binary_pairs:\n")
      
      for sketch in self.sketches:
         
         f.writeRaw("    - old_binary: \"%s\"\n" % (sketch.old_firmware_binary))
         f.writeRaw("      new_binary: \"%s\"\n" % (sketch.new_firmware_binary))
         f.writeRaw("      short_name: \"%s\"\n" % (sketch.relpath))
         f.writeRaw("\n")
      
   def generateMultiReport(self):
            
      print "Generating multi-report"
      
      cmd = [  self.elf_diff_executable, \
               "--driver-file", self.driver_file, \
               "--mass_report" \
            ]
      
      print "Driver file: %s" % (self.driver_file)
      
      self.runSubprocess(cmd)
      
   def parseCommandLineArgs(self):
      
      self.remove_html_file = False

      parser = argparse.ArgumentParser(description="Compare two firmware bundles and generate a change report.")
      parser.add_argument("--old_sketch", default = None, dest="old_sketch_filename", help="The old Arduino sketch")
      parser.add_argument("--new_sketch", default = None, dest="new_sketch_filename", help="The new Arduino sketch")
      parser.add_argument("sketches", nargs="*", default = None, help="The sketches (this is an alternative to --old-sketch and --new-sketch)")
      parser.add_argument("--old_kaleidoscope_repo", default = None, dest="old_repo_path", help="Path to the old kaleidoscope repo")
      parser.add_argument("--new_kaleidoscope_repo", default = None, dest="new_repo_path", help="Path to the new kaleidoscope repo")      
      parser.add_argument("--title", default=None, dest="change_title", help="A title to use for the report")
      parser.add_argument("--elf_diff-executable", default=None, dest="elf_diff_executable", help="An absolute path to the elf_diff exectuable.")
      parser.add_argument("--report_file_basename", default=None, dest="report_file_basename", help="The path of the report file to generated.")
      parser.add_argument("--report_target_dir", default=None, dest="report_target_dir", help="The path where to store report files.")      
      parser.add_argument("-v", "--verbose", dest="verbose_output", help="Enable verbose output.", action='store_true')
      actual_args = list()
      for arg_pos in range(1, len(sys.argv)):
         arg = sys.argv[arg_pos]
         if arg == "--":
               break
         actual_args.append(arg)
           
      args = parser.parse_args(actual_args)
      
      self.verbose_output = args.verbose_output
      
      self.report_target_dir = args.report_target_dir
      if self.report_target_dir:
         if not os.path.exists(self.report_target_dir):
            os.makedirs(self.report_target_dir)
      else:
         self.report_target_dir \
            = os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe())))
      
      if args.report_file_basename:
         self.report_file_basename = args.report_file_basename
      else:
         self.report_file_basename = "kaleidoscope_change_report"
      
      self.old_sketch_filename = None
      self.new_sketch_filename = None
      
      if len(args.sketches) == 0:
         if args.old_sketch_filename:
            self.old_sketch_filename = args.old_sketch_filename
            
         if args.new_sketch_filename:
            self.new_sketch_filename = args.new_sketch_filename
      elif len(args.sketches) == 2:
         if args.old_sketch_filename:
            print "Old sketch filename redundantly defined"
            exit(1)
         else:
            self.old_sketch_filename = args.sketches[0]
            
         if args.new_sketch_filename:
            print "Old sketch filename redundantly defined"
            exit(1)
         else:
            self.new_sketch_filename = args.sketches[1]
      else:
         print "Please specify either none or two sketches"
         exit(1)
         
      self.old_repo_path = args.old_repo_path
      self.new_repo_path = args.new_repo_path
         
      self.change_title = args.change_title
         
      if self.old_sketch_filename:
         self.old_bundle_dir = os.path.realpath(os.path.dirname(self.old_sketch_filename) + "/../../..")
      elif self.old_repo_path:
         self.old_bundle_dir = self.old_repo_path + "/../../.."
      else:
         print "Unable to determine old bundle directory."
         exit(1)
         
      if self.new_sketch_filename:
         self.new_bundle_dir = os.path.realpath(os.path.dirname(self.new_sketch_filename) + "/../../..")
      elif self.new_repo_path:
         self.new_bundle_dir = self.new_repo_path + "/../../.."
      else:
         print "Unable to determine new bundle directory."
         exit(1)
      
      self.old_bundle_submodule_info_file \
         = self.generateOutputFilename("old_bundle_submodules.txt")
      
      self.new_bundle_submodule_info_file \
         = self.generateOutputFilename("new_bundle_submodules.txt")
         
      if os.environ["ARDUINO_PATH"] != "":
         self.arduino_path = os.environ["ARDUINO_PATH"]
      elif os.environ["ARDUINO_SDK_PATH"] != "":
         self.arduino_path = os.environ["ARDUINO_SDK_PATH"]
      else:
         print "Unable to detect Arduino path. Please specify either environment variable ARDUINO_PATH or ARDUINO_SDK_PATH."
         sys.exit(1)

      if args.elf_diff_executable:
         if os.path.isfile(args.elf_diff_executable) and os.access(args.elf_diff_executable, os.X_OK):
            self.elf_diff_executable = args.elf_diff_executable
      else:
         self.elf_diff_executable = which("elf_diff")
         if not self.elf_diff_executable:
            print "Unable to find elf_diff. Please specify it manually or add its location to the PATH variable."
            sys.exit(1)
      
   def runSubprocess(self, cmd, cwd = os.getcwd(), env = os.environ.copy()):
      
      if self.verbose_output:
         print "   Running command: %s" % ("\"" + "\" \"".join(cmd) + "\"")
      #print "   In: " + cwd
      #print "   ENV = %s" % (env)
      
      #for key, value in env.iteritems():
      #   print "%s = %s" % (key, value)
      
      try:
         proc = subprocess.Popen(cmd, \
                                 stdout = subprocess.PIPE, \
                                 stderr = subprocess.PIPE, \
                                 cwd = cwd, \
                                 env = env)
         
         o, e = proc.communicate()
         
         rc = proc.returncode
            
         output = o.decode("utf8")
         error = e.decode("utf8")
         
      except (OSError) as e:
         print e
         sys.exit(1)
      
      if rc != 0:
         print "Failed running command %s in directory %s failed" % (str(cmd), cwd)
         print "   exit code: %d" % (rc)
         print "   stdout: %s" % (output)
         print "   stderr: %s" % (error)
         sys.exit(1)
         
      if self.verbose_output:
         print "      exit code: %d" % (rc)
         if len(output) > 0:
            print "      stdout: %s" % (output)
            
         if len(error) > 0:
            print "      stderr: %s" % (error)
         
      return [output, error]
   
   def collectBuildInfo(self):

      arduino_build_info = self.runSubprocess([self.arduino_path + "/arduino-builder", "-version"])[0]
      
      gcc_version_output = self.runSubprocess([self.arduino_path + "/hardware/tools/avr/bin/avr-g++", "-v"])[1]
      
      gcc_version_regex = r"gcc version (\d+\.\d+\.\d+) "
      matches = re.finditer(gcc_version_regex, gcc_version_output, re.MULTILINE)

      firmware_binary = None
      
      for matchNum, match in enumerate(matches, start=1):
         gcc_version = "gcc version: " + match.group(1)
         break
      
      self.build_info = arduino_build_info
      self.build_info += "\n\n"
      self.build_info += gcc_version
      
   def generateGitSubmoduleInfoFile(self, bundle_dir, info_file):
      
      print "Collecting git submodule info in %s" % (bundle_dir)

      cmd = ["git", "submodule"]
      
      git_submodule_output = self.runSubprocess(cmd, cwd = bundle_dir)[0]
      
      output_file = open(info_file, "w")
      
      output_file.write(git_submodule_output)
   
   def generateBundleSubmoduleInfoFiles(self):
      
      self.generateGitSubmoduleInfoFile(self.old_bundle_dir, self.old_bundle_submodule_info_file)
      self.generateGitSubmoduleInfoFile(self.new_bundle_dir, self.new_bundle_submodule_info_file)
      
   def buildFirmware(self, hardware_path, build_dir, 
                     sketch_file = None, extra_env = None, make_command = None):

      if sketch_file:
         print "Building firmware sketch %s" % (sketch_file)
      else:
         print "Building firmware in %s" % (build_dir)
      
      cmd = ["make"]
      
      if make_command:
         cmd.append(make_command)
      
      my_env = os.environ.copy()
      my_env["BOARD_HARDWARE_PATH"] = hardware_path
      
      if extra_env:
         my_env.update(extra_env)
      
      firmware_build_output = self.runSubprocess(cmd, cwd = build_dir, env = my_env)[0]
      
      build_info_regex = r"Building\s+(\.*\/*\S*)\s+.*\s+into\s+(.*)\.\.\."
      
      matches = re.finditer(build_info_regex, firmware_build_output, re.MULTILINE)

      firmware_binary = None
      
      for matchNum, match in enumerate(matches, start=1):
            
         sketch_basename = os.path.basename(match.group(1))
         
         firmware_binary = "%s/%s-latest.elf" % (match.group(2), sketch_basename)
         break
      
      if not firmware_binary:
      
         build_info_regex = r"Building (\S*)[.\S\s]*Your compiled sketch can be found in (.*)\n"

         matches = re.finditer(build_info_regex, firmware_build_output, re.MULTILINE)

         firmware_binary = None
         
         for matchNum, match in enumerate(matches, start=1):
            
            sketch_basename = os.path.basename(match.group(1))
            
            firmware_binary = "%s/%s-latest.elf" % (match.group(2), sketch_basename)
            break

      if not firmware_binary:
         print "Failed decoding firmware build info"
         print "Info is:"
         print "%s" % (firmware_build_output)
         sys.exit(1)

      return firmware_binary
      
   def buildFirmwares(self):
      
      old_hardware_path = self.old_bundle_dir + "/.."
      new_hardware_path = self.new_bundle_dir + "/.."
      
      old_build_dir = os.path.dirname(self.old_sketch_filename)
      new_build_dir = os.path.dirname(self.new_sketch_filename)
      
      self.old_firmware_binary \
         = self.buildFirmware(old_hardware_path, old_build_dir, \
                              sketch_file = self.old_sketch_filename)
      
      self.new_firmware_binary \
         = self.buildFirmware(new_hardware_path, new_build_dir, \
                              sketch_file = self.new_sketch_filename)
   
   def generatePairReportDriverFile(self):
      
      self.driver_file = self.generateOutputFilename("driver.yaml")
            
      if self.change_title:
         project_title = "Kaleidoscope: " + self.change_title
      else:
         project_title = "Kaleidoscope: <Unknown Change>"
         
      pdf_file = self.generateOutputFilename("pdf")
      html_file = self.generateOutputFilename("html")
      
      f = DriverFile(self.driver_file)
         
      f.writeParameter("project_title", project_title)
      f.writeParameter("bin_dir", self.arduino_path + "/hardware/tools/avr/bin")
      f.writeParameter("bin_prefix", "avr-")
      f.writeParameter("old_binary_filename", str(self.old_firmware_binary))
      f.writeParameter("new_binary_filename", str(self.new_firmware_binary))
      f.writeParameter("old_alias", "Old Kaleidoscope firmware (see version info below)")
      f.writeParameter("new_alias", "New Kaleidoscope firmware (see version info below)")
      f.writeParameter("pdf_file", pdf_file)
      f.writeParameter("html_file", html_file)
      f.writeParameter("old_info_file", self.old_bundle_submodule_info_file)
      f.writeParameter("new_info_file", self.new_bundle_submodule_info_file)
      f.writeParameter("build_info", self.build_info)

   def generatePairReport(self):
      
      print "Generating pair report"
      
      cmd = [  self.elf_diff_executable, \
               "--driver_file", self.driver_file]
      
      self.runSubprocess(cmd)
      
   def cleanup(self):
      
      if os.path.isfile(self.old_bundle_submodule_info_file):
         os.remove(self.old_bundle_submodule_info_file)
      if os.path.isfile(self.new_bundle_submodule_info_file):
         os.remove(self.new_bundle_submodule_info_file)
      
if __name__ == "__main__":
   driver = LCR()
